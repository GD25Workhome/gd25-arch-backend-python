# 示例代码使用说明

本文档介绍如何使用脚手架提供的示例代码，包括 Model、Schema、Repository、Service 和 API 的完整示例。

## 一、示例代码概述

脚手架提供了一个完整的用户（User）管理示例，展示了如何从数据模型到 API 路由的完整开发流程。

### 示例代码结构

```
app/
├── models/
│   └── user.py              # 用户模型
├── schemas/
│   └── user.py              # 用户 Schema（数据验证）
├── repositories/
│   └── user_repository.py   # 用户 Repository（数据访问层）
├── services/
│   └── user_service.py      # 用户服务（业务逻辑层）
└── api/
    └── users.py              # 用户 API 路由
```

## 二、使用步骤

### 步骤 1：创建数据库表

首先需要创建用户表，使用 Alembic 进行数据库迁移：

```bash
# 生成迁移脚本
alembic revision --autogenerate -m "Add user model"

# 执行迁移
alembic upgrade head
```

### 步骤 2：注册 API 路由

在 `app/main.py` 中注册用户路由：

```python
from app.api.users import router as users_router

# 注册用户路由
app.include_router(users_router, prefix="/api/v1")
```

### 步骤 3：启动服务

```bash
uvicorn app.main:app --reload
```

### 步骤 4：测试 API

访问 API 文档：http://localhost:8100/docs

## 三、示例代码详解

### 3.1 Model（数据模型）

**文件**：`app/models/user.py`

```python
from app.db.base import BaseModel
from sqlalchemy import Column, String, Integer, Boolean

class User(BaseModel):
    """用户模型"""
    __tablename__ = "users"
    
    name = Column(String(100), nullable=False)
    email = Column(String(255), unique=True, nullable=False)
    age = Column(Integer, nullable=True)
    is_active = Column(Boolean, default=True)
```

**特点**：
- 继承自 `BaseModel`，自动包含 `id`、`created_at`、`updated_at` 字段
- 使用 SQLAlchemy 定义数据库表结构
- 支持索引、唯一约束等数据库特性

### 3.2 Schema（数据验证）

**文件**：`app/schemas/user.py`

```python
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    """创建用户 Schema"""
    name: str
    email: EmailStr
    age: Optional[int] = None
    is_active: bool = True

class UserResponse(BaseModel):
    """用户响应 Schema"""
    id: int
    name: str
    email: str
    # ... 其他字段
```

**特点**：
- 使用 Pydantic 进行数据验证
- 支持自动类型转换和验证
- 可以定义不同的 Schema 用于创建、更新、响应等场景

### 3.3 Repository（数据访问层）

**文件**：`app/repositories/user_repository.py`

```python
from app.repositories.base import BaseRepository

class UserRepository(BaseRepository[User]):
    """用户 Repository"""
    
    def __init__(self, db: Session):
        super().__init__(User, db)
    
    def get_by_email(self, email: str) -> Optional[User]:
        """根据邮箱获取用户"""
        return self.filter_one(User.email == email)
```

**特点**：
- 继承自 `BaseRepository`，自动获得 CRUD 操作
- 可以添加业务特定的查询方法
- 支持分页、搜索等高级功能

### 3.4 Service（业务逻辑层）

**文件**：`app/services/user_service.py`

```python
class UserService:
    """用户服务"""
    
    def __init__(self, db: Session):
        self.repository = UserRepository(db)
    
    def create_user(self, user_data: UserCreate) -> User:
        """创建用户（包含业务验证）"""
        # 检查邮箱是否已存在
        if self.repository.get_by_email(user_data.email):
            raise ValidationError("邮箱已被使用")
        
        return self.repository.create(user_data.model_dump())
```

**特点**：
- 处理业务逻辑和验证
- 协调 Repository 和业务规则
- 处理事务和异常

### 3.5 API（路由层）

**文件**：`app/api/users.py`

```python
from fastapi import APIRouter, Depends

router = APIRouter(prefix="/users", tags=["用户"])

@router.post("/", response_model=dict)
async def create_user(
    user_data: UserCreate,
    service: UserService = Depends(get_user_service),
):
    """创建用户"""
    user = service.create_user(user_data)
    return success_response(data=user)
```

**特点**：
- 使用 FastAPI 路由定义 API 端点
- 使用依赖注入获取 Service 实例
- 自动生成 API 文档

## 四、API 端点说明

注册路由后，可以使用以下 API 端点：

### 创建用户

```bash
POST /api/v1/users
Content-Type: application/json

{
  "name": "张三",
  "email": "zhangsan@example.com",
  "age": 25,
  "is_active": true
}
```

### 获取用户

```bash
GET /api/v1/users/{user_id}
```

### 更新用户

```bash
PUT /api/v1/users/{user_id}
Content-Type: application/json

{
  "name": "李四",
  "age": 30
}
```

### 删除用户

```bash
DELETE /api/v1/users/{user_id}
```

### 获取用户列表

```bash
GET /api/v1/users?page=1&page_size=10&is_active=true
```

### 搜索用户

```bash
GET /api/v1/users/search?keyword=张三&page=1&page_size=10
```

## 五、自定义扩展

### 5.1 添加新字段

1. **修改 Model**：在 `app/models/user.py` 中添加新字段
2. **修改 Schema**：在 `app/schemas/user.py` 中添加对应的字段
3. **生成迁移**：运行 `alembic revision --autogenerate -m "Add new field"`
4. **执行迁移**：运行 `alembic upgrade head`

### 5.2 添加新方法

1. **Repository**：在 `UserRepository` 中添加查询方法
2. **Service**：在 `UserService` 中添加业务逻辑方法
3. **API**：在 `app/api/users.py` 中添加新的路由端点

### 5.3 添加新模型

参考用户示例，创建新的模型：
1. 创建 Model（`app/models/xxx.py`）
2. 创建 Schema（`app/schemas/xxx.py`）
3. 创建 Repository（`app/repositories/xxx_repository.py`）
4. 创建 Service（`app/services/xxx_service.py`）
5. 创建 API（`app/api/xxx.py`）
6. 在 `app/main.py` 中注册路由

## 六、最佳实践

1. **分层清晰**：Model → Schema → Repository → Service → API
2. **职责单一**：每层只负责自己的职责
3. **依赖注入**：使用 FastAPI 的依赖注入机制
4. **异常处理**：使用统一的异常类
5. **类型提示**：所有函数都要有完整的类型提示
6. **文档字符串**：所有类和方法都要有文档字符串

## 七、注意事项

1. **数据库迁移**：修改 Model 后必须生成和执行迁移
2. **Schema 验证**：确保 Schema 定义与 Model 字段一致
3. **事务管理**：Service 层负责事务管理
4. **错误处理**：使用统一的异常类和响应格式
5. **测试**：为每个层编写单元测试

## 八、参考文档

- [Repository 使用示例](./repository使用示例.md)
- [FastAPI 官方文档](https://fastapi.tiangolo.com/)
- [SQLAlchemy 官方文档](https://docs.sqlalchemy.org/)
- [Pydantic 官方文档](https://docs.pydantic.dev/)

